#!/usr/bin/env ruby

dir = File.expand_path('../../', __FILE__)
require "#{dir}/lib/nuri"
require "coderay"

version = File.read(File.dirname(__FILE__) + "/../VERSION").strip
#Nuri #{version} (c) 2013

banner = <<-EOS
Usage: nuri [command]
where [command] is:
  state     get the current state
  plan      generate the plan
  bsig      deployment with distributed mechanism
  agent     manage Nuri agent

EOS

def process_args(args, parser)
	Trollop::with_standard_exception_handling parser do
		parser.parse args
	end
end

def check_help(args)
	help = args.count { |x| x == '-h' or x == '--help' }
	[(help > 0), args.select { |x| x != '-h' and x != '--help' }]
end

def do_state(args=ARGV, cmd="nuri ")
	parser = Trollop::Parser.new do
		banner <<-EOS
Usage: #{cmd}state [options]
where [options] are:
EOS
	opt :model_file, 'Model file of the desired state.', :default => 'main.sfp', :short => '-m'
	opt :plain, 'Print output in plain JSON.'
end
	help, args = check_help(args)
	opts = process_args args, parser

	if help
		parser.educate(STDOUT)
	elsif File.exist?(opts[:model_file])
		master = Nuri::Master.new
		master.set_model opts
		state = master.get_state opts
		state.accept(Sfp::Visitor::PrettyStateGenerator.new)
		puts (opts[:plain] ? JSON.generate(state) : CodeRay.encode(JSON.pretty_generate(state), :json, :terminal))
	else
		puts "Model file '#{opts[:model_file]}' is not exist! Use \"-h\" option for more details.".red
	end
end

def do_plan(args=ARGV, cmd="nuri ")
	parser = Trollop::Parser.new do
		banner <<-EOS
Usage: #{cmd}plan [options]
where [options] are:
EOS
	opt :model_file, 'Model file of the desired state.', :default => 'main.sfp', :short => '-m'
	opt :parallel, 'Generate a parallel plan.', :short => '-l'
	opt :plain, 'Print output in plain JSON.'
	opt :no_interactive, 'Disable interactive input.'
end
	help, args = check_help(args)
	opts = process_args args, parser

	if help
		parser.educate(STDOUT)
	elsif File.exist?(opts[:model_file])
		opts[:plan] = true
		master = Nuri::Master.new
		master.set_model(opts)
		plan = master.get_plan(opts)
		if plan.is_a?(Hash) and !plan['workflow'].nil?
			if plan['workflow'].length > 0
				if opts[:plain]
					puts JSON.generate(plan)
				else
					actions = plan['workflow']
					if plan['type'] == 'sequential'
						p = 'Sequential Plan:'.yellow
						actions.each_index { |i| p += "\n#{i+1}. #{actions[i]['name']} #{JSON.generate(actions[i]['parameters'])}" }
						puts p
					else
						p = 'Partial-Order Plan:'.yellow
						actions.each { |op| p += "\n#{op['id']+1}. #{op['name']} #{JSON.generate(op['parameters'])} (#{op['predecessors'].map{|i|i+1}}, #{op['successors'].map{|i|i+1}})" }
						puts p
					end
				end

				if not opts[:no_interactive] and plan['workflow'].length > 0
					print "Execute the plan [y/N]? "
					if STDIN.gets.chomp.upcase == 'Y'
						puts 'Executing the plan: '.yellow
						opts[:plan] = plan
						if master.execute_plan(opts)
							puts "Execution success!".green
						else
							puts "Execution failed!".red
						end
					end
				end
			else
				puts (opts[:plain] ? 'Goal state has been achieved.' : 'Goal state has been achieved.'.green)
			end
		else
			puts (opts[:plain] ? "No solution!" : "No solution!".red)
		end
	else
		puts "Model file '#{opts[:model_file]}' is not exist! Use \"-h\" option for more details.".red
	end
end

def do_bsig(args=ARGV, cmd="nuri ")
	parser = Trollop::Parser.new do
		banner <<-EOS
Usage: #{cmd}bsig [options]
where [options] are:
EOS
	opt :model_file, 'Model file of the desired state.', :default => 'main.sfp', :short => '-m'
	opt :purge, 'Purge the existing BSig model.', :short => '-g'
	opt :deploy, 'Generate and then deploy the BSig model.'
	opt :plain, 'Print output in plain JSON.'
	opt :no_interactive, 'Disable interactive input.'
end
	help, args = check_help(args)
	opts = process_args args, parser

	if help
		parser.educate(STDOUT)
	elsif File.exist?(opts[:model_file])
		opts[:bsig_deploy] = true
		opts[:parallel] = true
		master = Nuri::Master.new
		master.set_model(opts)

		if opts[:purge]
			if master.purge_bsig(opts)
				puts "Purging Behavioural Signature model [OK]".green
			else
				puts "Purging Behavioural Signature model [Failed]".red
			end
		else
			bsig = master.get_bsig(opts)
			if bsig.is_a?(Hash) and bsig.length > 0
				empty_local_bsig = bsig.select { |name,local_bsig| local_bsig['operators'].length <= 0 }
				if empty_local_bsig.length != bsig.length
					if opts[:plain]
						puts JSON.generate(bsig)
					else
						puts CodeRay.encode(JSON.pretty_generate(bsig), :json, :terminal)
					end
	
					if not opts[:no_interactive] and not opts[:deploy]
						print "Deploy the BSig model [y/N]? "
						opts[:deploy] = true if STDIN.gets.chomp.upcase == 'Y'
					end

					if opts[:deploy]
						puts 'Deploying the BSig model: '.yellow
						opts[:bsig] = bsig
						if master.deploy_bsig(opts)
							puts "Deployment success!".green
						else
							puts "Deployment failed!".red
						end
					end
				else
					puts (opts[:plain] ? 'Goal state has been achieved.' : 'Goal state has been achieved.'.green)
				end
			else
				puts (opts[:plain] ? "No solution!" : "No solution!".red)
			end
		end
	else
		puts "Model file '#{opts[:model_file]}' is not exist! Use \"-h\" option for more details.".red
	end
end

def do_agent(args=ARGV, cmd="nuri ")
	parser = Trollop::Parser.new do
		banner <<-EOS
Usage: #{cmd}agent <subcommand> [options]
where <subcommand> is:
 install:   install agent on target node
 upgrade:   upgrade agent
   start:   start the agent (use SSH for remote agent)
    stop:   stop the agent (use SSH for remote agent)
  status:   get agent's status
   state:   get agent's current state
   model:   get agent's current model
    bsig:   get agent's current Behavioural Signature model
  module:   get agent's modules list
     log:   get last 100 lines of logs
  
where [options] are:
EOS
	opt :address, "Agent's address.", :default => 'localhost'
	opt :ssh_user, "Agent's SSH username.", :short => '-u'
	opt :ssh_port, "Agent's SSH port.", :short => '-p'
end
	help, args = check_help(args)
	subcommand = (args.length > 0 ? args.shift : '')
	opts = process_args args, parser
	ssh_opt = ''
	if opts[:address] != 'localhost'
		ssh_opt = "ssh "
		ssh_opt += (opts[:ssh_user] ? "#{opts[:ssh_user]}@#{opts[:address]}" : opts[:address])
		ssh_opt += (opts[:ssh_port] ? "-p #{opts[:ssh_port]}" : '')
	end

	if help
		parser.educate(STDOUT)
	elsif `which sfpagent`.strip.length > 0
		case subcommand
		when 'install'
			system("#{ssh_opt} sudo gem install sfpagent --no-ri --no-rdoc")
		when 'start'
			system("#{ssh_opt} sfpagent -s")
		when 'stop'
			system("#{ssh_opt} sfpagent -t")
		when 'status'
			system("#{ssh_opt} sfpagent -a")
		when 'upgrade'
			system("#{ssh_opt} sudo gem update sfpagent --no-ri --no-rdoc")
		when 'state'
			state = JSON[Net::HTTP.get("#{opts[:address]}", "/state", 1314)]['state']
			state.keys.each { |key| state.delete(key) if state[key]['_context'] != 'object' }
			state.accept(Sfp::Visitor::PrettyStateGenerator.new)
			puts CodeRay.encode(JSON.pretty_generate(state), :json, :terminal)
		when 'model'
			model = JSON[Net::HTTP.get("#{opts[:address]}", "/model", 1314)]
			model.keys.each { |key| model.delete(key) if model[key]['_context'] != 'object' }
			model.accept(Sfp::Visitor::PrettyStateGenerator.new)
			puts CodeRay.encode(JSON.pretty_generate(model), :json, :terminal)
		when 'bsig'
			json = Net::HTTP.get("#{opts[:address]}", "/bsig", 1314)
			puts CodeRay.encode(JSON.pretty_generate(JSON[json]), :json, :terminal) if json.length >= 2
		when 'module'
			json = Net::HTTP.get("#{opts[:address]}", "/modules", 1314)
			puts CodeRay.encode(JSON.pretty_generate(JSON[json]), :json, :terminal) if json.length >= 2
		when 'log'
			puts Net::HTTP.get "#{opts[:address]}", "/log", 1314
		when 'help'
			parser.educate(STDOUT)
		else
			puts 'Unrecognized command!'
		end
	else
		puts 'sfpagent gem is not installed!'.red
	end
end

def do_edit(args)
	file = args[0].to_s
	if file == '-h' or file == '--help'
		puts <<-EOS
Usage: edit <filepath>
EOS
	elsif File.exist?(file)
		system("vi #{file}")
	else
		puts 'Target file is not specified!'
	end
end

def do_console
	banner = <<-EOS
Usage: <command> [options]
when <command> is:
  state     get the current state
  plan      generate the plan
  bsig      deployment with distributed mechanism
  agent     manage Nuri agent
  edit      edit a file
  help      print this help
  exit      exit the console

EOS

	loop do
		print 'nuri> '
		begin
			input = STDIN.gets
			raise Exception if input.nil?
		rescue Exception
			puts ''
			break
		end
		input = input.chomp.strip
		command, args = input.split(' ', 2)
		args = args.to_s.split(' ')
		case command
		when 'state'
			do_state args, ''
		when 'plan'
			do_plan args, ''
		when 'bsig'
			do_bsig args, ''
		when 'agent'
			do_agent args, ''
		when 'edit'
			do_edit args
		when 'help'
			puts banner
		when 'exit', 'quit', 'q'
			break
		end
	end
	puts "Bye!\n"
end

if ARGV.length > 0
	success = false
	case ARGV.shift
	when 'state'
		do_state
	when 'plan'
		do_plan
	when 'bsig'
		do_bsig
	when 'agent'
		do_agent
	when 'console'
		do_console
	else
		puts banner
	end
else
	puts banner
end
