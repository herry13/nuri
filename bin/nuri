#!/usr/bin/env ruby

dir = File.expand_path(File.dirname(__FILE__)) + '/../lib'
require "#{dir}/nuri"

require 'coderay'
require 'logger'

version = File.read(File.dirname(__FILE__) + '/../VERSION').sub(/\n/, '')

opts = Trollop::options do
	version "Nuri #{version} (c) 2013"
	banner <<-EOS
Usage: nuri [options]
where [options] are:
EOS

	opt :model_file, "Model of configuration file.", :default => ''
	opt :state, "Print the current state of the system in JSON based on given model file."
	opt :plan, "Print the plan that could bring the system to the desired state as defined in model file."
	opt :parallel, "Generate a parallel plan.", :short => '-l'
	opt :bsig_deploy, "Generate and deploy Behavioural Signature model"
	opt :bsig_purge, "Purge Behavioural Signature model"
	opt :execute, "Execute a plan in given file. Note: model file should be specified.", :default => ''
	opt :apply, "Generate and execute a plan that could bring the system to the desired state."
	opt :push_modules, "Automatically push an unavailable module to target agent."
	opt :human, "Use human readable format."
	opt :pretty, "Use pretty JSON format."
	opt :silent, "Set off interactive mode.", :defaut => true
	opt :start, "Start master daemon.", :short => '-s'
	opt :stop, "Stop master daemon.", :short => '-t'
end

def plan_to_human(plan)
	return 'No solution plan.'.red if plan['workflow'].nil?
	return 'The system is at the goal state.'.green if plan['workflow'].length <= 0

	p = ''
	actions = plan['workflow']
	if plan['type'] == 'sequential'
		p = 'Sequential Plan:'.yellow
		actions.each_index { |i| p += "\n#{i+1}. #{actions[i]['name']} #{actions[i]['parameters']}" }
	else
		p = 'Partial-Order Plan:'.yellow
		actions.each { |op| p += "\n#{op['id']+1}. #{op['name']} #{op['parameters']} (#{op['predecessors'].map{|i|i+1}}, #{op['successors'].map{|i|i+1}})" }
	end
	p
end

def verify_model(opts)
	if opts[:model_file].length <= 0
		puts "Model file is not specified! Use \"-h\" option for more details.".red
		exit(false)
	end
end

if opts[:state]
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	state = master.get_state(opts)
	state.accept(Sfp::Visitor::PrettyStateGenerator.new)
	if opts[:human]
		puts CodeRay.encode(JSON.pretty_generate(state), :json, :terminal)
	else
		puts (opts[:pretty] ? JSON.pretty_generate(state) : JSON.generate(state))
	end

elsif opts[:plan]
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	plan = master.get_plan(opts)
	if !plan.is_a?(Hash) or plan['workflow'].nil?
		puts "Plan: ".yellow + "\nno solution!".red
	else
		if opts[:human]
			puts plan_to_human(plan)
		else
			puts (opts[:pretty] ? JSON.pretty_generate(plan) : JSON.generate(plan))
		end

		if not opts[:no_interactive] and not plan['workflow'].nil? and plan['workflow'].length > 0
			print "Execute the plan [y/N]? "
			if STDIN.gets.chomp.upcase == 'Y'
				puts 'Executing the plan:'.yellow
				opts[:plan] = plan
				puts (master.execute_plan(opts) ? "Execution success!".green : "Execution failed!".red)
			end
		end
	end

elsif opts[:execute].length > 0
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	puts (master.execute_plan(opts) ? "Execution success!".green : "Execution failed!".red)

elsif opts[:apply]
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	plan = master.get_plan(opts)
	if plan['workflow'].nil?
		puts "No solution!".red
	else
		if opts[:human]
			puts plan_to_human(plan)
		else
			puts (opts[:pretty] ? JSON.pretty_generate(plan) : JSON.generate(plan))
		end

		puts 'Executing the plan...'.yellow
		opts[:plan] = plan
		puts (master.execute_plan(opts) ? "Execution success!".green : "Execution failed!".red)
	end

elsif opts[:bsig_deploy]
	verify_model(opts)
	opts[:parallel] = true

	master = Nuri::Master.new
	master.set_model(opts)
	bsig = master.get_bsig(opts)

	if !bsig.is_a?(Hash)
		puts "\nNo solution!".red
	else
		if opts[:human]
			puts CodeRay.encode(JSON.pretty_generate(bsig), :json, :terminal)
		else
			puts (opts[:pretty] ? JSON.pretty_generate(bsig) : JSON.generate(bsig))
		end

		if not opts[:no_interactive] and bsig.is_a?(Hash) and bsig.length > 0
			print "Deploy the BSig model [y/N]? "
			if STDIN.gets.chomp.upcase == 'Y'
				puts 'Deploying the BSig model:'.yellow
				opts[:bsig] = bsig
				puts (master.deploy_bsig(opts) ? "Deployment success!".green : "Deployment failed!".red)
			end
		end
	end

elsif opts[:bsig_purge]
	verify_model(opts)

	puts "Purging Behavioural Signature model...".yellow
	master = Nuri::Master.new
	master.set_model(opts)
	if master.purge_bsig(opts)
		puts "Purging Behavioural Signature model [OK]".green
	else
		puts "Purging Behavioural Signature model [Failed]".red
	end

elsif opts[:start]
	puts "Not implemented yet!".red

elsif opts[:stop]
	puts "Not implemented yet!".red

else
	Trollop::help
end
