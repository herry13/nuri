#!/usr/bin/env ruby

dir = File.expand_path('../../', __FILE__)
require "#{dir}/lib/nuri"
require "coderay"

Version = File.read(File.dirname(__FILE__) + "/../VERSION").strip
About = "Nuri #{Version} (c) 2013"

class Sfp::Console
	def process_args(args, parser)
		Trollop::with_standard_exception_handling parser do
			parser.parse args
		end
	end

	def check_help(args)
		help = args.count { |x| x == '-h' or x == '--help' }
		[(help > 0), args.select { |x| x != '-h' and x != '--help' }]
	end

	def do_state(args=ARGV, cmd="nuri ")
		parser = Trollop::Parser.new do
			banner <<-EOS
Usage: #{cmd}state [options]
where [options] are:
EOS
			opt :model_file, 'Model file of the desired state.', :default => 'main.sfp', :short => '-m'
			opt :plain, 'Print output in plain JSON.'
			opt :no_push_module, 'disable automatic push module'
		end
		help, args = check_help(args)
		opts = process_args args, parser

		if help
			parser.educate(STDOUT)
		elsif File.exist?(opts[:model_file])
			opts[:push_modules] = true if !opts[:no_push_module]
			master = Nuri::Master.new
			master.set_model opts
			state = master.get_state opts
			state.accept(Sfp::Visitor::PrettyStateGenerator.new)
			puts (opts[:plain] ? JSON.generate(state) : CodeRay.encode(JSON.pretty_generate(state), :json, :terminal))
		else
			puts "Model file '#{opts[:model_file]}' is not exist! Use \"-h\" option for more details.".red
		end
	end

	def do_plan(args=ARGV, cmd="nuri ")
		parser = Trollop::Parser.new do
			banner <<-EOS
Usage: #{cmd}plan [options]
where [options] are:
EOS
			opt :model_file, 'model file of the desired state', :default => 'main.sfp', :short => '-m'
			opt :parallel, 'generate a parallel plan', :short => '-l'
			opt :apply, 'execute any generated plan', :short => '-a'
			opt :plain, 'print output in plain JSON'
			opt :no_interactive, 'disable interactive input'
			opt :no_push_module, 'disable automatic push module'
		end
		help, args = check_help(args)
		opts = process_args args, parser
	
		if help
			parser.educate(STDOUT)
		elsif File.exist?(opts[:model_file])
			opts[:plan] = true
			opts[:push_modules] = true if !opts[:no_push_module]
			master = Nuri::Master.new
			master.set_model(opts)
			plan = master.get_plan(opts)
			if plan.is_a?(Hash) and !plan['workflow'].nil?
				if plan['workflow'].length > 0
					if opts[:plain]
						puts JSON.generate(plan)
					else
						actions = plan['workflow']
						if plan['type'] == 'sequential'
							p = 'Sequential Plan:'.yellow
							actions.each_index { |i| p += "\n#{i+1}. #{actions[i]['name']} #{JSON.generate(actions[i]['parameters'])}" }
							puts p
						else
							p = 'Partial-Order Plan:'.yellow
							actions.each { |op| p += "\n#{op['id']+1}. #{op['name']} #{JSON.generate(op['parameters'])} (#{op['predecessors'].map{|i|i+1}}, #{op['successors'].map{|i|i+1}})" }
							puts p
						end
					end

					if not opts[:apply] and not opts[:no_interactive]
						print "Execute the plan [y/N]? "
						opts[:apply] = true if STDIN.gets.chomp.upcase == 'Y'
					end

					if opts[:apply]
						puts 'Executing the plan: '.yellow
						opts[:plan] = plan
						if master.execute_plan(opts)
							puts "Execution success!".green
						else
							puts "Execution failed!".red
						end
					end
				elsif plan['workflow'].length == 0
					puts (opts[:plain] ? 'Goal state has been achieved.' : 'Goal state has been achieved.'.green)
				end
			else
				puts (opts[:plain] ? "No solution!" : "No solution!".red)
			end
		else
			puts "Model file '#{opts[:model_file]}' is not exist! Use \"-h\" option for more details.".red
		end
	end

	def do_bsig(args=ARGV, cmd="nuri ")
		parser = Trollop::Parser.new do
			banner <<-EOS
Usage: #{cmd}bsig [options]
where [options] are:
EOS
			opt :model_file, 'Model file of the desired state.', :default => 'main.sfp', :short => '-m'
			opt :purge, 'Purge the existing BSig model.', :short => '-g'
			opt :deploy, 'Generate and then deploy the BSig model.'
			opt :plain, 'Print output in plain JSON.'
			opt :no_interactive, 'Disable interactive input.'
		end
		help, args = check_help(args)
		opts = process_args args, parser

		if help
			parser.educate(STDOUT)
		elsif File.exist?(opts[:model_file])
			opts[:bsig_deploy] = true
			opts[:parallel] = true
			master = Nuri::Master.new
			master.set_model(opts)
	
			if opts[:purge]
				if master.purge_bsig(opts)
					puts "Purging Behavioural Signature model [OK]".green
				else
					puts "Purging Behavioural Signature model [Failed]".red
				end
			else
				bsig = master.get_bsig(opts)
				if bsig.is_a?(Hash) and bsig.length > 0
					empty_local_bsig = bsig.select { |name,local_bsig| local_bsig['operators'].length <= 0 }
					if empty_local_bsig.length != bsig.length
						if opts[:plain]
							puts JSON.generate(bsig)
						else
							puts CodeRay.encode(JSON.pretty_generate(bsig), :json, :terminal)
						end
		
						if not opts[:no_interactive] and not opts[:deploy]
							print "Deploy the BSig model [y/N]? "
							opts[:deploy] = true if STDIN.gets.chomp.upcase == 'Y'
						end
	
						if opts[:deploy]
							puts 'Deploying the BSig model: '.yellow
							opts[:bsig] = bsig
							if master.deploy_bsig(opts)
								puts "Deployment success!".green
							else
								puts "Deployment failed!".red
							end
						end
					else
						puts (opts[:plain] ? 'Goal state has been achieved.' : 'Goal state has been achieved.'.green)
					end
				else
					puts (opts[:plain] ? "No solution!" : "No solution!".red)
				end
			end
		else
			puts "Model file '#{opts[:model_file]}' is not exist! Use \"-h\" option for more details.".red
		end
	end

	def do_agent(args=ARGV, cmd="nuri ")
		parser = Trollop::Parser.new do
			banner <<-EOS
Usage: #{cmd}agent <subcommand> [node] [options]
where <subcommand> is:
 install     install agent
 upgrade     upgrade agent (use SSH for remote node)
   start     start the agent (use SSH for remote node)
    stop     stop the agent (use SSH for remote node)
  status     get status
   state     get current state
   model     get current model
    bsig     get current Behavioural Signature model
  module     get modules list
     log     get last 100 lines of logs
    list     list of agents
  
where [options] are:
EOS
			opt :address, "address", :default => 'localhost'
			opt :port, "port", :default => 1314
			opt :ssh_user, "SSH username", :short => '-u'
			opt :ssh_port, "SSH port", :short => '-p'
		end
		help, args = check_help(args)
		subcommand = (args.length > 0 ? args.shift : '')
		opts = process_args args, parser
		ssh_opt = ''
		if opts[:address] != 'localhost'
			ssh_opt = "ssh "
			ssh_opt += (opts[:ssh_user] ? "#{opts[:ssh_user]}@#{opts[:address]}" : opts[:address])
			ssh_opt += (opts[:ssh_port] ? "-p #{opts[:ssh_port]}" : '')
		end
	
		if help
			parser.educate(STDOUT)
		elsif `which sfpagent`.strip.length > 0
			case subcommand
			when 'install'
				system("#{ssh_opt} sudo gem install sfpagent --no-ri --no-rdoc")
			when 'start'
				system("#{ssh_opt} sfpagent -s")
			when 'stop'
				system("#{ssh_opt} sfpagent -t")
			when 'status'
				system("#{ssh_opt} sfpagent -a")
			when 'upgrade'
				system("#{ssh_opt} sudo gem update sfpagent --no-ri --no-rdoc")
			when 'state'
				state = JSON[Net::HTTP.get("#{opts[:address]}", "/state", 1314)]['state']
				state.keys.each { |key| state.delete(key) if state[key]['_context'] != 'object' }
				state.accept(Sfp::Visitor::PrettyStateGenerator.new)
				puts CodeRay.encode(JSON.pretty_generate(state), :json, :terminal)
			when 'model'
				model = JSON[Net::HTTP.get("#{opts[:address]}", "/model", 1314)]
				model.keys.each { |key| model.delete(key) if model[key]['_context'] != 'object' }
				model.accept(Sfp::Visitor::PrettyStateGenerator.new)
				puts CodeRay.encode(JSON.pretty_generate(model), :json, :terminal)
			when 'bsig'
				json = Net::HTTP.get("#{opts[:address]}", "/bsig", 1314)
				puts CodeRay.encode(JSON.pretty_generate(JSON[json]), :json, :terminal) if json.length >= 2
			when 'module'
				json = Net::HTTP.get("#{opts[:address]}", "/modules", 1314)
				puts CodeRay.encode(JSON.pretty_generate(JSON[json]), :json, :terminal) if json.length >= 2
			when 'log'
				puts Net::HTTP.get "#{opts[:address]}", "/log", 1314
			when 'list'
				get_agents.each { |name,model| puts "#{name} address=#{model['sfpAddress']} port=#{model['sfpPort']}" }
			when 'help'
				parser.educate(STDOUT)
			else
				puts 'Unrecognized command!'
			end
		else
			puts 'sfpagent gem is not installed!'.red
		end
	end

	def do_edit(args)
		file = (args[0].nil? ? 'main.sfp' : args[0].to_s)
		if file == '-h' or file == '--help'
			puts <<-EOS
Usage: edit <filepath>
EOS
		elsif File.exist?(file)
			system("vi #{file}")
		else
			puts 'Target file is not specified!'
		end
	end

	def get_agents(args={})
		model_file = (args[:model_file] ? args[:model_file].to_s : 'main.sfp')
		models = (File.exist?(model_file) ? Nuri::Master.agents(Sfp::Parser.parse_file(model_file)) : {})
		agents = {}
		models.each do |name,model|
			agents[name] = {
				'sfpAddress' => (model['sfpAddress'].is_a?(String) ? model['sfpAddress'] : ''),
				'sfpPort' => (model['sfpPort'].is_a?(Fixnum) ? model['sfpPort'] : 0)
			}
		end
		agents
	end

	def do_console
		banner = <<-EOS
Usage: <command> [options]
when <command> is:
  state     get the current state
   plan     generate the plan
   bsig     deployment with distributed mechanism
  agent     manage Nuri agent
   edit     edit a file
   help     print this help
   exit     exit the console

EOS

		puts About
		loop do
			begin
				print 'nuri> '.green
				begin
					input = STDIN.gets
					raise Exception if input.nil?
				rescue Exception
					puts ''
					break
				end
				input = input.chomp.strip
				if input[0] == '!'
					system(input[1..input.length])
				else
					command, args = input.split(' ', 2)
					break if command == 'exit' or command == 'quit' or command == 'q'
					args = args.to_s.split(' ')
					command = args[0] and args = ['-h'] if command == 'help' and args.length > 0
					case command
					when 'state'
						do_state args, ''
					when 'plan'
						do_plan args, ''
					when 'bsig'
						do_bsig args, ''
					when 'agent'
						do_agent args, ''
					when 'edit'
						do_edit args
					when 'help'
						puts banner
					when 'version', '-v'
						puts About
					else
						$stderr.puts 'Unrecognized command! Type "help" to print available commands.'
					end
				end
			rescue Exception => e
				puts "#{e}\n#{e.backtrace.join("\n")}"
			end
		end
		puts "Bye!\n"
	end

	def run
		banner = <<-EOS
Usage: nuri [command]
where [command] is:
    state     get the current state
     plan     generate the plan
     bsig     deployment with distributed mechanism
    agent     manage Nuri agent
  console     enter console

EOS

		if ARGV.length > 0
			success = false
			case ARGV.shift
			when 'state'
				do_state
			when 'plan'
				do_plan
			when 'bsig'
				do_bsig
			when 'agent'
				do_agent
			when 'console'
				do_console
			else
				puts banner
			end
		else
			puts banner
		end
	end
end

Sfp::Console.new.run if $0 == __FILE__
