#!/usr/bin/env ruby

dir = File.expand_path(File.dirname(__FILE__)) + '/../lib'
require "#{dir}/nuri"

require 'coderay'
require 'logger'

version = File.read(File.dirname(__FILE__) + '/../VERSION').sub(/\n/, '')

opts = Trollop::options do
	version "Nuri #{version} (c) 2013"
	banner <<-EOS
Usage: nuri [options]
where [options] are:
EOS

	opt :model_file, "Model of configuration file.", :default => '', :short => '-m'
	opt :state, "Print the current state of the system in JSON based on given model file.", :short => '-s'
	opt :plan, "Print the plan that could bring the system to the desired state as defined in model file.", :short => '-p'
	opt :parallel, "Generate a parallel plan.", :short => '-l'
	opt :bsig_deploy, "Generate and deploy Behavioural Signature model", :short => '-b'
	opt :bsig_purge, "Purge Behavioural Signature model", :short => '-g'
	opt :execute, "Execute a plan in given file. Note: model file should be specified.", :default => '', :short => '-x'
	opt :apply, "Generate and execute a plan that could bring the system to the desired state.", :short => '-a'
	opt :push_modules, "Automatically push an unavailable module to target agent.", :short => '-u'
	opt :human, "Use human readable format.", :short => '-h'
	opt :pretty, "Use pretty JSON format.", :short => '-r'
	opt :silent, "Set off interactive mode.", :defaut => true, :short => '-n'
	#opt :start, "Start master daemon.", :short => '-s'
	#opt :stop, "Stop master daemon.", :short => '-t'
end

def plan_to_human(plan)
	return 'No solution plan.'.red if plan['workflow'].nil?
	return 'The system is at the goal state.'.green if plan['workflow'].length <= 0

	p = ''
	actions = plan['workflow']
	if plan['type'] == 'sequential'
		p = 'Sequential Plan:'.yellow
		actions.each_index { |i| p += "\n#{i+1}. #{actions[i]['name']} #{JSON.generate(actions[i]['parameters'])}" }
	else
		p = 'Partial-Order Plan:'.yellow
		actions.each { |op| p += "\n#{op['id']+1}. #{op['name']} #{JSON.generate(op['parameters'])} (#{op['predecessors'].map{|i|i+1}}, #{op['successors'].map{|i|i+1}})" }
	end
	p
end

def verify_model(opts)
	if opts[:model_file].length <= 0
		puts "Model file is not specified! Use \"-h\" option for more details.".red
		exit(false)
	end
end

if opts[:state]
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	state = master.get_state(opts)
	state.accept(Sfp::Visitor::PrettyStateGenerator.new)
	if opts[:human]
		puts CodeRay.encode(JSON.pretty_generate(state), :json, :terminal)
	else
		puts (opts[:pretty] ? JSON.pretty_generate(state) : JSON.generate(state))
	end

elsif opts[:plan]
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	plan = master.get_plan(opts)
	if !plan.is_a?(Hash) or plan['workflow'].nil?
		puts "Plan: ".yellow + "\nno solution!".red
	else
		if opts[:human]
			puts plan_to_human(plan)
		else
			puts (opts[:pretty] ? JSON.pretty_generate(plan) : JSON.generate(plan))
		end

		if not opts[:silent] and plan['workflow'].is_a?(Array) and plan['workflow'].length > 0
			print "Execute the plan [y/N]? "
			if STDIN.gets.chomp.upcase == 'Y'
				puts 'Executing the plan:'.yellow
				opts[:plan] = plan
				puts (master.execute_plan(opts) ? "Execution success!".green : "Execution failed!".red)
			end
		end
	end

elsif opts[:execute].length > 0
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	puts (master.execute_plan(opts) ? "Execution success!".green : "Execution failed!".red)

elsif opts[:apply]
	verify_model(opts)

	master = Nuri::Master.new
	master.set_model(opts)
	plan = master.get_plan(opts)
	if not plan.is_a?(Hash)
		puts "No solution!".red
	else
		if opts[:human]
			puts plan_to_human(plan)
		else
			puts (opts[:pretty] ? JSON.pretty_generate(plan) : JSON.generate(plan))
		end

		if plan['workflow'].is_a?(Array) and plan['workflow'].length > 0
			puts 'Executing the plan...'.yellow
			opts[:plan] = plan
			puts (master.execute_plan(opts) ? "Execution success!".green : "Execution failed!".red)
		end
	end

elsif opts[:bsig_deploy]
	verify_model(opts)
	opts[:parallel] = true

	master = Nuri::Master.new
	master.set_model(opts)
	bsig = master.get_bsig(opts)

	if not bsig.is_a?(Hash)
		puts "\nNo solution!".red
	elsif bsig.length > 0
		empty_local_bsig = bsig.select { |name,local_bsig| local_bsig['operators'].length <= 0 }

		if empty_local_bsig.length == bsig.length
			puts "The goal state has been achieved!".green

		else
			# print the BSig model
			if opts[:human]
				puts CodeRay.encode(JSON.pretty_generate(bsig), :json, :terminal)
			else
				puts (opts[:pretty] ? JSON.pretty_generate(bsig) : JSON.generate(bsig))
			end

			if not opts[:silent]
				print "Deploy the BSig model [y/N]? "
				if STDIN.gets.chomp.upcase == 'Y'
					puts 'Deploying the BSig model:'.yellow
					opts[:bsig] = bsig
					puts (master.deploy_bsig(opts) ? "Deployment success!".green : "Deployment failed!".red)
				end
			end

		end
	end

elsif opts[:bsig_purge]
	verify_model(opts)

	puts "Purging Behavioural Signature model...".yellow
	master = Nuri::Master.new
	master.set_model(opts)
	if master.purge_bsig(opts)
		puts "Purging Behavioural Signature model [OK]".green
	else
		puts "Purging Behavioural Signature model [Failed]".red
	end

=begin
elsif opts[:start]
	puts "Not implemented yet!".red

elsif opts[:stop]
	puts "Not implemented yet!".red
=end

else
	Trollop::help
end
